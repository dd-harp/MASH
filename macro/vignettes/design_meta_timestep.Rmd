---
title: "Design of Generation of Discrete Time Steps"
output: html_notebook
---
From `r system("git config --get remote.origin.url", intern = TRUE)`
on `r date()`, generated by `r Sys.info()[["effective_user"]]`.

# Overview

Looking for a way to specify a time step more easily.

```{r function_start}
f0 <- function(x) substitute(x)
f0(x + y)
```

What's a formula?
```{r formula1}
for1 <- y ~ x1 * x2 + x3
for1[[1]] == as.name("~")
for1[[2]] == as.name("y")
for1[[3]] == quote(x1 * x2 + x3)
```


```{r tease_apart}
eqns <- list(
U ~ -h * U + r * X,
X ~ h * U - r * X
)

read_states <- function(equation) lapply(equation, function(x) x[[2]])
(states <- read_states(eqns))
states_index <- 1:length(states)
names(states_index) <- as.character(states)
stopifnot(states_index["X"] == 2)
```
```{r pull_pieces}
terms <- quote(a + b)
class(terms) == "call"
terms[[1]] == "+"
(left <- terms[[2]])
(right <- terms[[3]])
class(left)
```
```{r end_point}
pull_term <- function(terms) {
  if (is.call(terms) && terms[[1]] == "+") {
    left <- terms[[2]]
    right <- terms[[3]]
    return(c(pull_term(left), pull_term(right)))
  } else if (is.call(terms) && terms[[1]] == "-") {
    left <- terms[[2]]
    # Move the minus sign to be a factor on the second term.
    # The second term is always by itself, while the first can be more terms.
    right <- call("*", -1, terms[[3]])
    return(c(pull_term(left), pull_term(right)))
  } else {
    return(terms)
  }
}
(pull_term(quote(a + b)))
(pull_term(quote(e + e - f - g)))
```

```{r pull_factors}
pull_factor <- function(terms) {
  if (class(terms) == "call" && terms[[1]] == "*") {
    left <- terms[[2]]
    right <- terms[[3]]
    return(c(pull_factor(left), pull_factor(right)))
  } else {
    return(list(terms))
  }
}
(pull_factor(quote(a * b)))
(pull_factor(quote(e * e * f)))
pull_factor(quote(a))
```

```{r combine_factors}
combine_factors <- function(factors) {
  if (length(factors) == 2) {
    return(call("*", factors[[1]], factors[[2]]))
  } else if (length(factors) > 2) {
    return(call("*", factors[[1]], factors[2:length(factors)]))
  } else {
    return(factors[[1]])
  }
}
```

```{r prrrrr}
rhs <- eqns[[1]][[3]]
terms <- pull_term(rhs)
factors <- pull_factor(terms[[1]])

term_to_argument <- function(factors, states) {
  for (fac_idx in 1:length(factors)) {
    for (state_idx in 1:length(states)) {
      if (factors[[fac_idx]] == states[[state_idx]]) {
        column_name <- factors[[fac_idx]]
        factors[[fac_idx]] <- NULL
        argument <- list(combine_factors(factors))
        names(argument) <- as.character(column_name)
        return(argument)
      }
    }
  }
  stop("Factor not found")
}
term_to_argument(factors, states)
```
```{r}
args <- list()
for (term_idx in 1:length(terms)) {
  args <- c(args, term_to_argument(pull_factor(terms[[term_idx]]), states))
}
args
```
Put this together to make a normalized form.
```{r}
normalized_equations <- function(equations) {
  read_states <- function(equation) lapply(equation, function(x) x[[2]])
  states_index <- 1:length(states)
  names(states_index) <- as.character(states)
  
  righthand <- vector(mode = "list", length = length(states_index))
  names(righthand) <- as.character(states)
  
  for (eq_idx in 1:length(equations)) {
    rhs <- equations[[eq_idx]][[3]]
    terms <- pull_term(rhs)
    args <- list()
    for (term_idx in 1:length(terms)) {
      factors <- pull_factor(terms[[term_idx]])
      #cat(paste(factors, "\n"))
      args <- c(args, term_to_argument(factors, states))
    }
    righthand[[eq_idx]] <- args
  }
  righthand
}
eqns <- c(
U ~ -h * U + cos(r) * X,
X ~ h * U - r * X
)
normalized_equations(eqns)
```

