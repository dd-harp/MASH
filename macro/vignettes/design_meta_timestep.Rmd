---
title: "Design of Generation of Discrete Time Steps"
output: html_notebook
---
From `r system("git config --get remote.origin.url", intern = TRUE)`
on `r date()`, generated by `r Sys.info()[["effective_user"]]`.

# Overview

I'd like to be able to build a time step quickly from a specification, at least for some
simple models. In this case, I'm thinking about specifying linear equations with coefficients
that are constant across a time step.
$$
\frac{dx}{dt}=Ax=\left[\begin{array}{cc}-h & \sin(r) \\ h & -\sin(r)\end{array}\right]x
$$
I'm using a $\sin$ there to make the point that the rates can be arbitrary functions of
parameters. We could write that equation as
```{r tease_apart}
si_equations <- list(
U ~ -h * U + sin(r) * X,
X ~ h * U - sin(r) * X
)
```
I'll assume this is a differential form of an ODE that reflects a master equation.
That is, I'll assume that everything that leaves one compartment enters another compartment
and that there are no constant terms.

From this kind of specification, we can produce lots of different kinds of time steps.

# Discrete Time Steps

## The Matrix for the Master Equation
Most of them are simple permutations of the specification. The simplest is a function
that returns what it received, the matrix $A$. We can look at the text of the function itself, thanks
to R's ability to print the body of a function.
```{r example_cme}
(si_cme <- cme_maker(si_equations))
```
This function executes, given a parameter list.
```{r example_cme_execute}
si_cme(list(h = 0.4, r = 0.1))
```
How would you use this? You could pass this function to an ODE solver
in order to get change across a step with constant parameters.

## Small Time Step
For small time steps, we approximate the time step as $I-A t$.
```{r create_small}
(si_small <- small_step_maker(si_equations))
```
We can execute it by passing in the original parameters, plus a time.
```{r run_small}
si_small(list(h = 0.4, r = 0.1, t = 0.05))
```

How do you use this?
The small time step is a very common way to build steps. We think
of rate times time as the marginal probability for a jump in a Markov
chain. If parameters keep changing, then this function can build the matrix quickly.
If you wanted to simulate a long interval that has constant
parameters, you could split it into $2^(2n)$ steps and square this matrix
$n$ times.


# Fiddling with Metaprogramming

Looking for a way to specify a time step more easily.

```{r function_start}
f0 <- function(x) substitute(x)
f0(x + y)
```

What's a formula?
```{r formula1}
for1 <- y ~ x1 * x2 + x3
for1[[1]] == as.name("~")
for1[[2]] == as.name("y")
for1[[3]] == quote(x1 * x2 + x3)
```


```{r tease_apart}
eqns <- list(
U ~ -h * U + r * X,
X ~ h * U - r * X
)

read_states <- function(equation) lapply(equation, function(x) x[[2]])
(states <- read_states(eqns))
states_index <- 1:length(states)
names(states_index) <- as.character(states)
stopifnot(states_index["X"] == 2)
```
```{r pull_pieces}
terms <- quote(a + b)
class(terms) == "call"
terms[[1]] == "+"
(left <- terms[[2]])
(right <- terms[[3]])
class(left)
```
```{r end_point}
pull_term <- function(terms) {
  if (is.call(terms) && terms[[1]] == "+") {
    left <- terms[[2]]
    right <- terms[[3]]
    return(c(pull_term(left), pull_term(right)))
  } else if (is.call(terms) && terms[[1]] == "-") {
    left <- terms[[2]]
    # Move the minus sign to be a factor on the second term.
    # The second term is always by itself, while the first can be more terms.
    right <- call("*", -1, terms[[3]])
    return(c(pull_term(left), pull_term(right)))
  } else {
    return(terms)
  }
}
(pull_term(quote(a + b)))
(pull_term(quote(e + e - f - g)))
```

```{r pull_factors}
pull_factor <- function(terms) {
  if (class(terms) == "call" && terms[[1]] == "*") {
    left <- terms[[2]]
    right <- terms[[3]]
    return(c(pull_factor(left), pull_factor(right)))
  } else {
    return(list(terms))
  }
}
(pull_factor(quote(a * b)))
(pull_factor(quote(e * e * f)))
pull_factor(quote(a))
```

```{r combine_factors}
combine_factors <- function(factors) {
  if (length(factors) == 2) {
    return(call("*", factors[[1]], factors[[2]]))
  } else if (length(factors) > 2) {
    return(call("*", factors[[1]], factors[2:length(factors)]))
  } else {
    return(factors[[1]])
  }
}
```

```{r prrrrr}
rhs <- eqns[[1]][[3]]
terms <- pull_term(rhs)
factors <- pull_factor(terms[[1]])

term_to_argument <- function(factors, states) {
  for (fac_idx in 1:length(factors)) {
    for (state_idx in 1:length(states)) {
      if (factors[[fac_idx]] == states[[state_idx]]) {
        column_name <- factors[[fac_idx]]
        factors[[fac_idx]] <- NULL
        argument <- list(combine_factors(factors))
        names(argument) <- as.character(column_name)
        return(argument)
      }
    }
  }
  stop("Factor not found")
}
term_to_argument(factors, states)
```
```{r}
args <- list()
for (term_idx in 1:length(terms)) {
  args <- c(args, term_to_argument(pull_factor(terms[[term_idx]]), states))
}
args
```
Put this together to make a normalized form.
```{r}
normalized_equations <- function(equations) {
  read_states <- function(equation) lapply(equation, function(x) x[[2]])
  states_index <- 1:length(states)
  names(states_index) <- as.character(states)
  
  righthand <- vector(mode = "list", length = length(states_index))
  names(righthand) <- as.character(states)
  
  for (eq_idx in 1:length(equations)) {
    rhs <- equations[[eq_idx]][[3]]
    terms <- pull_term(rhs)
    args <- list()
    for (term_idx in 1:length(terms)) {
      factors <- pull_factor(terms[[term_idx]])
      #cat(paste(factors, "\n"))
      args <- c(args, term_to_argument(factors, states))
    }
    righthand[[eq_idx]] <- args
  }
  righthand
}
eqns <- c(
U ~ -h * U + cos(r) * X,
X ~ h * U - r * X
)
(normed <- normalized_equations(eqns))
```
Now construct a function from the normalized equations. Let's just make
a body first. Can we make a matrix?
```{r make_matrix}
make_matrix <- call(
  "matrix",
  call(
    "c",
    1,
    2
    ),
  2
  )
names(make_matrix) <- c("", "", "ncol")
eval(make_matrix)
```
We can programmatically generate the matrix.
```{r longer_matrix}
(quoted_array <- do.call(call, c("c",as.list(1:10))))
eval(quoted_array)
```

```{r matrix_of_symbols}
make_matrix <- call(
  "matrix",
  call(
    "c",
    normed$U$U,
    normed$U$X,
    normed$X$U,
    normed$X$X
    ),
  2
  )
names(make_matrix) <- c("", "", "ncol")
eval(make_matrix, list(h = 0.4, r = 0.1))
```
```{r in_function_body}
# Try making a pre-made function and modifying it.
cme_matrix <- function(parameters) with(parameters, matrix(c(1), nrow = 1))
(bb <- body(cme_matrix))
(mat_maker <- bb[[3]])
(list_action <- mat_maker[[2]])
list_action[[2]] <- normed$X$U
list_action[[3]] <- normed$X$X
# set the number of rows
mat_maker[[3]] <- 2
mat_maker
```
```{r make_from_normed}
cme_maker <- function(normed) {
  cme_matrix <- function(parameters) with(parameters, matrix(c(1), nrow = 1))
  list_action <- vector(mode = "list", length = length(normed) + 1)
  list_action[[1]] <- as.name("c")
  list_idx <- 2
  state_name <- names(normed)
  for (col in 1:length(normed)) {
    col_name <- state_name[col]
    for (row in 1:length(normed)) {
      if (col_name %in% names(normed[[row]])) {
        list_action[[list_idx]] <- normed[[row]][[col_name]]
      } else {
        list_action[[list_idx]] <- 0
      }
      list_idx <- list_idx + 1
    }
  }
  body(cme_matrix)[[3]][[2]] <- as.call(list_action)
  body(cme_matrix)[[3]][[3]] <- length(normed)
  cme_matrix
}
cme_maker(normed)(list(h = 0.4, r = 0.1))
```
```{r}
small_step_maker <- function(normed) {
  cme_matrix <- function(parameters) with(parameters, matrix(c(1), nrow = 1))
  list_action <- vector(mode = "list", length = length(normed) + 1)
  list_action[[1]] <- as.name("c")
  list_idx <- 2
  state_name <- names(normed)
  for (col in 1:length(normed)) {
    col_name <- state_name[col]
    for (row in 1:length(normed)) {
      if (col_name %in% names(normed[[row]])) {
        if (row == col) {
          list_action[[list_idx]] <- call("+", call("*", normed[[row]][[col_name]], as.name("t")), 1)
        } else {
          list_action[[list_idx]] <- call("*", normed[[row]][[col_name]], as.name("t"))
        }
      } else {
        list_action[[list_idx]] <- ifelse(row == col, 1, 0)
      }
      list_idx <- list_idx + 1
    }
  }
  body(cme_matrix)[[3]][[2]] <- as.call(list_action)
  body(cme_matrix)[[3]][[3]] <- length(normed)
  cme_matrix
}
small_step <- small_step_maker(normed)
(small_step)
small_step(list(h = 0.4, r = 0.1, t = 0.02))
```
How about a full exponential?
```{r exponentiate}
exact_exponential <- function(normed) {
  cme_matrix <- function(parameters) with(parameters, expm::expm(matrix(c(1), nrow = 1)))
  list_action <- vector(mode = "list", length = length(normed) + 1)
  list_action[[1]] <- as.name("c")
  list_idx <- 2
  state_name <- names(normed)
  for (col in 1:length(normed)) {
    col_name <- state_name[col]
    for (row in 1:length(normed)) {
      if (col_name %in% names(normed[[row]])) {
        list_action[[list_idx]] <- call("*", normed[[row]][[col_name]], as.name("t"))
      } else {
        list_action[[list_idx]] <- 0
      }
      list_idx <- list_idx + 1
    }
  }
  body(cme_matrix)[[3]][[2]][[2]] <- as.call(list_action)
  body(cme_matrix)[[3]][[2]][[3]] <- length(normed)
  cme_matrix
}
(exact_exponential(normed))
exact_exponential(normed)(list(h = 0.4, r = 0.1, t = 2))
```

